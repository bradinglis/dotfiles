"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mock_fs_1 = __importDefault(require("mock-fs"));
const vscode_1 = require("../vscode");
describe('util/vscode', () => {
    describe('findEditorColor', () => {
        it('should be defined', () => {
            expect(vscode_1.findEditorColor).toBeDefined();
        });
        it('should find the requested color', () => {
            const mockEditorColors = {
                'activityBar.background': '#0A101E',
                'activityBar.foreground': '#D7DAE0',
                'activityBarBadge.background': '#a188f1',
                'activityBarBadge.foreground': '#F8FAFD'
            };
            expect(vscode_1.findEditorColor(mockEditorColors)(['activityBarBadge.background'])).toEqual(mockEditorColors['activityBarBadge.background']);
        });
        it('should return an empty string, if the color is not defined', () => {
            expect(vscode_1.findEditorColor({})(['activityBar'])).toEqual('');
        });
        it('should return an empty string, if the function is executed without parameters', () => {
            expect(vscode_1.findEditorColor({})([])).toEqual('');
        });
    });
    describe('findTokenColorForScope', () => {
        it('should be defined', () => {
            expect(vscode_1.findTokenColorForScope).toBeDefined();
        });
        it('should return the TokenColor for that given scope', () => {
            const mockTokenColors = [
                {
                    settings: {
                        foreground: '#6F7899'
                    },
                    name: 'Comments',
                    scope: 'comment, punctuation.definition.comment'
                },
                {
                    scope: [
                        'punctuation.definition',
                        'punctuation.definition.annotation',
                        'punctuation.definition.heading',
                        'punctuation.definition.list_item',
                        'punctuation.definition.thematic-break',
                        'punctuation.separator',
                        'punctuation.terminator',
                        'punctuation.accessor',
                        'punctuation.section',
                        'punctuation.support.type.property-name.begin',
                        'punctuation.support.type.property-name.end'
                    ],
                    settings: {
                        foreground: '#8892aa'
                    }
                }
            ];
            expect(vscode_1.findTokenColorForScope(mockTokenColors)('punctuation.section')).toEqual(mockTokenColors[1]);
        });
        it('should return null, if there is no TokenColor for the given scope', () => {
            expect(vscode_1.findTokenColorForScope([
                {
                    settings: {
                        foreground: '#6F7899'
                    },
                    name: 'Comments',
                    scope: 'comment, punctuation.definition.comment'
                }
            ])('activityBar')).toEqual(null);
        });
        it('should return null, if there is a TokenColor without a scope', () => {
            expect(vscode_1.findTokenColorForScope([
                {
                    settings: {
                        foreground: '#6F7899'
                    },
                    name: 'Comments'
                }
            ])('activityBar')).toEqual(null);
        });
        it('should return null, if the function is called without parameters', () => {
            expect(vscode_1.findTokenColorForScope([])('')).toEqual(null);
        });
    });
    describe('readCodeTheme', () => {
        afterEach(() => mock_fs_1.default.restore());
        it('should be defined', () => {
            expect(vscode_1.readCodeTheme).toBeDefined();
        });
        it('should read and return the json from the theme', () => __awaiter(void 0, void 0, void 0, function* () {
            const mockThemeDir = '/code/my-awesome-theme';
            const mockThemeName = 'awesome-theme.json';
            mock_fs_1.default({
                [mockThemeDir]: {
                    [mockThemeName]: `{
            name: 'Awesome Theme',
            author: 'Test'
          }`
                }
            });
            expect(yield vscode_1.readCodeTheme(mockThemeDir, mockThemeName)).toEqual({
                author: 'Test',
                name: 'Awesome Theme'
            });
        }));
        it('should throw an error, if the theme does not exist', () => __awaiter(void 0, void 0, void 0, function* () {
            expect.assertions(1);
            const mockThemeDir = 'e';
            const mockThemeName = 'awesome-theme.json';
            mock_fs_1.default({});
            return expect(vscode_1.readCodeTheme(mockThemeDir, mockThemeName)).rejects.toThrowError();
        }));
    });
    describe('readCodeThemePackage', () => {
        afterEach(() => mock_fs_1.default.restore());
        it('should be defined', () => {
            expect(vscode_1.readCodeThemePackage).toBeDefined();
        });
        it('should read and return the package.json from the theme', () => __awaiter(void 0, void 0, void 0, function* () {
            const mockThemeDir = '/code/my-awesome-theme';
            mock_fs_1.default({
                [mockThemeDir]: {
                    'package.json': `{
              "name": "pandju",
              "displayName": "Pandju",
              "description": "Raijū meets panda",
              "contributes": {
                "themes": [
                  {
                    "label": "Pandju",
                    "uiTheme": "vs-dark",
                    "path": "./themes/pandju.json"
                  },
                  {
                    "label": "Pandju - No italics",
                    "uiTheme": "vs-dark",
                    "path": "./themes/pandju-noitalic.json"
                  }
                ]
              }
          }`
                }
            });
            expect(yield vscode_1.readCodeThemePackage(mockThemeDir)).toEqual({
                name: 'pandju',
                displayName: 'Pandju',
                description: 'Raijū meets panda',
                contributes: {
                    themes: [
                        {
                            label: 'Pandju',
                            uiTheme: 'vs-dark',
                            path: './themes/pandju.json'
                        },
                        {
                            label: 'Pandju - No italics',
                            uiTheme: 'vs-dark',
                            path: './themes/pandju-noitalic.json'
                        }
                    ]
                }
            });
        }));
        it('should throw an error, if the theme does not exist', () => __awaiter(void 0, void 0, void 0, function* () {
            expect.assertions(1);
            const mockThemeDir = 'e';
            mock_fs_1.default({});
            return expect(vscode_1.readCodeThemePackage(mockThemeDir)).rejects.toThrowError();
        }));
    });
});
