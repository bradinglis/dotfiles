"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const plist_1 = __importDefault(require("plist"));
const uuid_1 = __importDefault(require("uuid"));
const vscode_1 = require("../util/vscode");
function toTmTheme(vscodeTheme, id) {
    const { name, author = '', type, colors, tokenColors } = vscodeTheme;
    const findEditorColorForFields = vscode_1.findEditorColor(colors);
    const sublimePlist = {
        name: vscodeTheme.name,
        settings: [
            {
                settings: {
                    accent: findEditorColorForFields(['list.highlightForeground']),
                    background: findEditorColorForFields(['editor.background']),
                    caret: findEditorColorForFields([
                        'editorCursor.background',
                        'editor.foreground'
                    ]),
                    foreground: findEditorColorForFields(['editor.foreground']),
                    lineHighlight: findEditorColorForFields([
                        'editor.lineHighlightBackground'
                    ]),
                    selection: findEditorColorForFields(['editor.selectionBackground']),
                    activeGuide: findEditorColorForFields([
                        'editorIndentGuide.background'
                    ]),
                    findHighlight: findEditorColorForFields([
                        'editor.findMatchHighlightBackground'
                    ]),
                    misspelling: findEditorColorForFields(['editorError.foreground'])
                }
            },
            ...generateGitGutterConfig(colors, tokenColors),
            ...tokenColors.map(convertTokenColorScopeForSublime)
        ],
        uuid: id !== null && id !== void 0 ? id : uuid_1.default.v4(),
        colorSpaceName: 'sRGB',
        semanticClass: `theme.${type}.${name.replace(/\s+/g, '-').toLowerCase()}`,
        author,
        comment: ''
    };
    return plist_1.default.build(sublimePlist);
}
exports.toTmTheme = toTmTheme;
function generateGitGutterConfig(colors, tokenColors) {
    const findEditorColorForFields = vscode_1.findEditorColor(colors);
    return [
        {
            name: 'GitGutter deleted',
            scope: 'markup.deleted.git_gutter',
            settings: {
                foreground: findEditorColorForFields([
                    'gitDecoration.deletedResourceForeground'
                ])
            }
        },
        {
            name: 'GitGutter inserted',
            scope: 'markup.inserted.git_gutter',
            settings: {
                foreground: findEditorColorForFields([
                    'gitDecoration.addedResourceForeground'
                ])
            }
        },
        {
            name: 'GitGutter changed',
            scope: 'markup.changed.git_gutter',
            settings: {
                foreground: findEditorColorForFields([
                    'gitDecoration.modifiedResourceForeground'
                ])
            }
        },
        {
            name: 'GitGutter untracked',
            scope: 'markup.untracked.git_gutter',
            settings: {
                foreground: findEditorColorForFields([
                    'gitDecoration.untrackedResourceForeground'
                ])
            }
        },
        {
            name: 'GitGutter ignored',
            scope: 'markup.ignored.git_gutter',
            settings: {
                foreground: findEditorColorForFields([
                    'gitDecoration.ignoredResourceForeground'
                ])
            }
        },
        {
            name: 'GitGutter comment',
            scope: 'comment.line.annotation.git_gutter',
            settings: {
                foreground: vscode_1.findTokenColorForScope(tokenColors)('comment, punctuation.definition.comment')
            }
        }
    ];
}
function convertTokenColorScopeForSublime(tokenColor) {
    if (tokenColor.scope == null || tokenColor.scope === '') {
        return Object.assign({}, tokenColor);
    }
    return Object.assign(Object.assign({}, tokenColor), { scope: Array.isArray(tokenColor.scope)
            ? tokenColor.scope.join(', ')
            : tokenColor.scope });
}
